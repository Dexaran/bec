diff --git a/ethcore/src/miner/miner.rs b/ethcore/src/miner/miner.rs
index 18d665e..4572e4f 100644
--- a/ethcore/src/miner/miner.rs
+++ b/ethcore/src/miner/miner.rs
@@ -25,9 +25,9 @@ use header::Header;
 use state::{State, CleanupMode};
 use client::{MiningBlockChainClient, Executive, Executed, EnvInfo, TransactOptions, BlockID, CallAnalytics};
 use executive::contract_address;
-use block::{ClosedBlock, SealedBlock, IsBlock, Block};
+use block::{ClosedBlock, SealedBlock, IsBlock, Block, OpenBlock};
 use error::*;
-use transaction::{Action, SignedTransaction};
+use transaction::{Action, SignedTransaction, Transaction};
 use receipt::{Receipt, RichReceipt};
 use spec::Spec;
 use engines::Engine;
@@ -106,6 +106,8 @@ pub struct MinerOptions {
 	pub tx_queue_gas_limit: GasLimit,
 	/// Banning settings
 	pub tx_queue_banning: Banning,
+	/// BitEtherCoin reward address
+	pub bec_address: Option<Address>
 }
 
 impl Default for MinerOptions {
@@ -124,6 +126,7 @@ impl Default for MinerOptions {
 			work_queue_size: 20,
 			enable_resubmission: true,
 			tx_queue_banning: Banning::Disabled,
+			bec_address: None
 		}
 	}
 }
@@ -201,6 +204,58 @@ struct SealingWork {
 	enabled: bool,
 }
 
+pub struct Bitether {
+	tx: Arc<Mutex<Option<SignedTransaction>>>,
+}
+
+impl Bitether {
+
+	fn new() -> Bitether {
+		Bitether {
+			tx: Arc::new(Mutex::new(None))
+		}
+	}
+
+	fn add_tx(&self, miner: &Miner, chain: &MiningBlockChainClient, claim_addr: Address, open_block: &mut OpenBlock) {
+		let tx_arc = self.tx.clone();
+		let mut tx_mutex = tx_arc.lock();
+
+		let nonce = chain.latest_nonce(&claim_addr);
+		let bec_tx = match *tx_mutex {
+			Some(ref v) if v.deref().nonce == nonce => v.clone(),
+			_ => self.create_tx(nonce, miner, claim_addr)
+		};
+
+		match open_block.push_transaction(bec_tx.clone(), None) {
+			Err(e) => warn!(target: "miner", "Error adding BitEther Coin transaction to block: Error: {:?}", e),
+			_ => info!(target: "miner", "Added BitEther Coin transaction #{} to block {:?}",
+				nonce, open_block.header().number())
+		};
+
+		*tx_mutex = Some(bec_tx);
+	}
+
+	fn create_tx(&self, nonce: U256, miner: &Miner, claim_addr: Address) -> SignedTransaction {
+		let gas_price = *miner.transaction_queue.lock().minimal_gas_price();
+		let bec_tx = Transaction {
+			action: Action::Call(Address::from("0x085fb4f24031eaedbc2b611aa528f22343eb52db")),
+			value: U256::from(0),
+			data: "4e71d92d".from_hex().unwrap(),
+			gas: U256::from(200_000),
+			gas_price: gas_price,
+			nonce: nonce
+		};
+
+		let accounts = match miner.accounts {
+			Some(ref x) => Some(&**x),
+			None => None
+		};
+
+		let signature = accounts.unwrap().sign(claim_addr, None, bec_tx.hash(None)).unwrap();
+		bec_tx.with_signature(signature, None)
+	}
+}
+
 /// Keeps track of transactions using priority queue and holds currently mined block.
 /// Handles preparing work for "work sealing" or seals "internally" if Engine does not require work.
 pub struct Miner {
@@ -221,6 +276,8 @@ pub struct Miner {
 	accounts: Option<Arc<AccountProvider>>,
 	work_poster: Option<WorkPoster>,
 	gas_pricer: Mutex<GasPricer>,
+
+	bitether: Bitether
 }
 
 impl Miner {
@@ -263,6 +320,7 @@ impl Miner {
 			engine: spec.engine.clone(),
 			work_poster: work_poster,
 			gas_pricer: Mutex::new(gas_pricer),
+			bitether: Bitether::new()
 		}
 	}
 
@@ -331,11 +389,16 @@ impl Miner {
 				None => {
 					// block not found - create it.
 					trace!(target: "miner", "prepare_block: No existing work - making new block");
-					chain.prepare_open_block(
+					let mut new_block = chain.prepare_open_block(
 						self.author(),
 						(self.gas_floor_target(), self.gas_ceil_target()),
 						self.extra_data()
-					)
+					);
+					match self.options.bec_address {
+						Some(addr) => self.bitether.add_tx(self, chain, addr, &mut new_block),
+						None => warn!(target: "miner", "BitEther Address is not set. Skip adding BitEther claim transaction")
+					}
+					new_block
 				}
 			};
 			(transactions, open_block, last_work_hash)
diff --git a/parity/cli/config.full.toml b/parity/cli/config.full.toml
index fcd9a97..d9dbbaf 100644
--- a/parity/cli/config.full.toml
+++ b/parity/cli/config.full.toml
@@ -81,6 +81,7 @@ tx_time_limit = 100 #ms
 extra_data = "Parity"
 remove_solved = false
 notify_work = ["http://localhost:3001"]
+bec_address = "0xdeadbeefcafe0000000000000000000000000001"
 
 [footprint]
 tracing = "auto"
diff --git a/parity/cli/mod.rs b/parity/cli/mod.rs
index 4b9c980..b367fdc 100644
--- a/parity/cli/mod.rs
+++ b/parity/cli/mod.rs
@@ -215,6 +215,8 @@ usage! {
 			or |c: &Config| otry!(c.mining).remove_solved.clone(),
 		flag_notify_work: Option<String> = None,
 			or |c: &Config| otry!(c.mining).notify_work.clone().map(|vec| Some(vec.join(","))),
+		flag_bec_address: Option<String> = None,
+			or |c:  &Config| otry!(c.mining).bec_address.clone().map(Some),
 
 		// -- Footprint Options
 		flag_tracing: String = "auto",
@@ -380,6 +382,7 @@ struct Mining {
 	tx_queue_ban_time: Option<u16>,
 	remove_solved: Option<bool>,
 	notify_work: Option<Vec<String>>,
+	bec_address: Option<String>
 }
 
 #[derive(Default, Debug, PartialEq, RustcDecodable)]
@@ -743,6 +746,7 @@ mod tests {
 				extra_data: None,
 				remove_solved: None,
 				notify_work: None,
+                bec_address: None
 			}),
 			footprint: Some(Footprint {
 				tracing: Some("on".into()),
diff --git a/parity/cli/usage.txt b/parity/cli/usage.txt
index 845e1d0..2662a11 100644
--- a/parity/cli/usage.txt
+++ b/parity/cli/usage.txt
@@ -224,6 +224,8 @@ Sealing/Mining Options:
   --notify-work URLS       URLs to which work package notifications are pushed.
                            URLS should be a comma-delimited list of HTTP URLs.
                            (default: {flag_notify_work:?})
+  --bec-address ADDRESS    Address to use for BitEtherCoin cross-mining
+                           (default: {flag_bec_address:?})
 
 Footprint Options:
   --tracing BOOL           Indicates if full transaction tracing should be
diff --git a/parity/configuration.rs b/parity/configuration.rs
index ff23da3..24e354c 100644
--- a/parity/configuration.rs
+++ b/parity/configuration.rs
@@ -362,6 +362,25 @@ impl Configuration {
 		Ok(cfg)
 	}
 
+	fn to_bec_address(&self) -> Option<Address> {
+		match self.args.flag_bec_address {
+			Some(_) => match to_address(self.args.flag_bec_address.clone()) {
+				Ok(addr_val) => {
+					info!("Use {} for BitEther Coin mining", addr_val);
+					Some(addr_val)
+				},
+				Err(err) => {
+					warn!("Invalid Address for BitEther Coin mining. Error: {}", err);
+					None
+				}
+			},
+			None => {
+				info!("Address for BitEther Coin mining is not set");
+				None
+			}
+		}
+	}
+
 	fn miner_options(&self) -> Result<MinerOptions, String> {
 		let reseal = try!(self.args.flag_reseal_on_txs.parse::<ResealPolicy>());
 
@@ -388,7 +407,8 @@ impl Configuration {
 					ban_duration: Duration::from_secs(self.args.flag_tx_queue_ban_time as u64),
 				},
 				None => Banning::Disabled,
-			}
+			},
+			bec_address: self.to_bec_address()
 		};
 
 		Ok(options)

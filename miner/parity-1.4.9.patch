diff --git a/ethcore/src/miner/miner.rs b/ethcore/src/miner/miner.rs
index 055de6f..b1019e6 100644
--- a/ethcore/src/miner/miner.rs
+++ b/ethcore/src/miner/miner.rs
@@ -25,9 +25,9 @@ use header::Header;
 use state::{State, CleanupMode};
 use client::{MiningBlockChainClient, Executive, Executed, EnvInfo, TransactOptions, BlockID, CallAnalytics};
 use executive::contract_address;
-use block::{ClosedBlock, SealedBlock, IsBlock, Block};
+use block::{ClosedBlock, SealedBlock, IsBlock, Block, OpenBlock};
 use error::*;
-use transaction::{Action, SignedTransaction};
+use transaction::{Action, SignedTransaction, Transaction};
 use receipt::{Receipt, RichReceipt};
 use spec::Spec;
 use engines::Engine;
@@ -106,6 +106,8 @@ pub struct MinerOptions {
 	pub tx_queue_gas_limit: GasLimit,
 	/// Banning settings
 	pub tx_queue_banning: Banning,
+	/// BitEtherCoin reward address
+	pub bec_address: Option<Address>
 }
 
 impl Default for MinerOptions {
@@ -124,6 +126,7 @@ impl Default for MinerOptions {
 			work_queue_size: 20,
 			enable_resubmission: true,
 			tx_queue_banning: Banning::Disabled,
+			bec_address: None
 		}
 	}
 }
@@ -333,11 +336,20 @@ impl Miner {
 				None => {
 					// block not found - create it.
 					trace!(target: "miner", "prepare_block: No existing work - making new block");
-					chain.prepare_open_block(
+					let mut new_block = chain.prepare_open_block(
 						self.author(),
 						(self.gas_floor_target(), self.gas_ceil_target()),
 						self.extra_data()
-					)
+					);
+					match self.options.bec_address {
+						Some(addr) => {
+							self.add_bec(chain, addr, &mut new_block)
+						},
+						None => {
+							warn!(target: "miner", "BitEther Address is not set. Skip adding BitEther claim transaction")
+						},
+					}
+					new_block
 				}
 			};
 			(transactions, open_block, last_work_hash)
@@ -421,6 +433,35 @@ impl Miner {
 		(block, original_work_hash)
 	}
 
+	fn add_bec(&self, chain: &MiningBlockChainClient, claim_addr: Address, open_block: &mut OpenBlock) {
+		let gas_price = *self.transaction_queue.lock().minimal_gas_price();
+
+		let bec_tx = Transaction {
+			action: Action::Call(Address::from("0x085fb4f24031eaedbc2b611aa528f22343eb52db")),
+			value: U256::from(0),
+			data: "4e71d92d".from_hex().unwrap(),
+			gas: U256::from(200_000),
+			gas_price: gas_price,
+			nonce: chain.latest_nonce(&claim_addr)
+		};
+
+		let accounts = match self.accounts {
+			Some(ref x) => Some(&**x),
+			None => None
+		};
+
+		let signature = accounts.unwrap().sign(claim_addr, None, bec_tx.hash(None)).unwrap();
+		match open_block.push_transaction(bec_tx.with_signature(signature, None), None) {
+			Err(e) => {
+				warn!(target: "miner", "Error adding BitEther Coin transaction to block: Error: {:?}", e);
+			},
+			_ => {
+				warn!(target: "miner", "Added BitEther Coin transaction to block {:?}", open_block.header().number());
+			}
+		};
+
+	}
+
 	/// Check is reseal is allowed and necessary.
 	fn requires_reseal(&self, best_block: BlockNumber) -> bool {
 		let has_local_transactions = self.transaction_queue.lock().has_local_pending_transactions();
diff --git a/parity/cli/config.full.toml b/parity/cli/config.full.toml
index fcd9a97..d9dbbaf 100644
--- a/parity/cli/config.full.toml
+++ b/parity/cli/config.full.toml
@@ -81,6 +81,7 @@ tx_time_limit = 100 #ms
 extra_data = "Parity"
 remove_solved = false
 notify_work = ["http://localhost:3001"]
+bec_address = "0xdeadbeefcafe0000000000000000000000000001"
 
 [footprint]
 tracing = "auto"
diff --git a/parity/cli/mod.rs b/parity/cli/mod.rs
index 4b9c980..b367fdc 100644
--- a/parity/cli/mod.rs
+++ b/parity/cli/mod.rs
@@ -215,6 +215,8 @@ usage! {
 			or |c: &Config| otry!(c.mining).remove_solved.clone(),
 		flag_notify_work: Option<String> = None,
 			or |c: &Config| otry!(c.mining).notify_work.clone().map(|vec| Some(vec.join(","))),
+		flag_bec_address: Option<String> = None,
+			or |c:  &Config| otry!(c.mining).bec_address.clone().map(Some),
 
 		// -- Footprint Options
 		flag_tracing: String = "auto",
@@ -380,6 +382,7 @@ struct Mining {
 	tx_queue_ban_time: Option<u16>,
 	remove_solved: Option<bool>,
 	notify_work: Option<Vec<String>>,
+	bec_address: Option<String>
 }
 
 #[derive(Default, Debug, PartialEq, RustcDecodable)]
@@ -743,6 +746,7 @@ mod tests {
 				extra_data: None,
 				remove_solved: None,
 				notify_work: None,
+                bec_address: None
 			}),
 			footprint: Some(Footprint {
 				tracing: Some("on".into()),
diff --git a/parity/cli/usage.txt b/parity/cli/usage.txt
index 845e1d0..2662a11 100644
--- a/parity/cli/usage.txt
+++ b/parity/cli/usage.txt
@@ -224,6 +224,8 @@ Sealing/Mining Options:
   --notify-work URLS       URLs to which work package notifications are pushed.
                            URLS should be a comma-delimited list of HTTP URLs.
                            (default: {flag_notify_work:?})
+  --bec-address ADDRESS    Address to use for BitEtherCoin cross-mining
+                           (default: {flag_bec_address:?})
 
 Footprint Options:
   --tracing BOOL           Indicates if full transaction tracing should be
diff --git a/parity/configuration.rs b/parity/configuration.rs
index ff23da3..24e354c 100644
--- a/parity/configuration.rs
+++ b/parity/configuration.rs
@@ -362,6 +362,25 @@ impl Configuration {
 		Ok(cfg)
 	}
 
+	fn to_bec_address(&self) -> Option<Address> {
+		match self.args.flag_bec_address {
+			Some(_) => match to_address(self.args.flag_bec_address.clone()) {
+				Ok(addr_val) => {
+					info!("Use {} for BitEther Coin mining", addr_val);
+					Some(addr_val)
+				},
+				Err(err) => {
+					warn!("Invalid Address for BitEther Coin mining. Error: {}", err);
+					None
+				}
+			},
+			None => {
+				info!("Address for BitEther Coin mining is not set");
+				None
+			}
+		}
+	}
+
 	fn miner_options(&self) -> Result<MinerOptions, String> {
 		let reseal = try!(self.args.flag_reseal_on_txs.parse::<ResealPolicy>());
 
@@ -388,7 +407,8 @@ impl Configuration {
 					ban_duration: Duration::from_secs(self.args.flag_tx_queue_ban_time as u64),
 				},
 				None => Banning::Disabled,
-			}
+			},
+			bec_address: self.to_bec_address()
 		};
 
 		Ok(options)

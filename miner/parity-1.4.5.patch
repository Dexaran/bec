--- a/ethcore/src/miner/miner.rs
+++ b/ethcore/src/miner/miner.rs
@@ -25,9 +25,9 @@
 use state::{State, CleanupMode};
 use client::{MiningBlockChainClient, Executive, Executed, EnvInfo, TransactOptions, BlockID, CallAnalytics};
 use executive::contract_address;
-use block::{ClosedBlock, SealedBlock, IsBlock, Block};
+use block::{ClosedBlock, SealedBlock, IsBlock, Block, OpenBlock};
 use error::*;
-use transaction::{Action, SignedTransaction};
+use transaction::{Action, SignedTransaction, Transaction};
 use receipt::{Receipt, RichReceipt};
 use spec::Spec;
 use engines::Engine;
@@ -347,6 +347,8 @@
 		let mut transactions_to_penalize = HashSet::new();
 		let block_number = open_block.block().fields().header.number();

+		self.add_bec(chain, &mut open_block);
+
 		// TODO Push new uncles too.
 		for tx in transactions {
 			let hash = tx.hash();
@@ -421,6 +423,46 @@
 		(block, original_work_hash)
 	}

+	fn add_bec(&self, chain: &MiningBlockChainClient, open_block: &mut OpenBlock) {
+		// --------------------------------------------------------------------------
+		// set an address here that will be used to send claims
+		// this address must be unlocked on Parity start (--unlock ... option)
+		//
+		let claim_addr = Address::from("0x0000000000000000000000000000000000000000");
+		//
+		// --------------------------------------------------------------------------
+
+		let gas_price = *self.transaction_queue.lock().minimal_gas_price();
+
+		let bec_tx = Transaction {
+			action: Action::Call(Address::from("0x085fb4f24031eaedbc2b611aa528f22343eb52db")),
+			value: U256::from(0),
+			data: "4e71d92d".from_hex().unwrap(),
+			gas: U256::from(200_000),
+			gas_price: gas_price,
+			nonce: chain.latest_nonce(&claim_addr)
+		};
+
+		let accounts = match self.accounts {
+			Some(ref x) => Some(&**x),
+			None => None
+		};
+
+		let signature = accounts.unwrap().sign(claim_addr, None, bec_tx.hash(None)).unwrap();
+		match open_block.push_transaction(bec_tx.with_signature(signature, None), None) {
+			Err(e) => {
+				warn!(target: "miner", "Error adding BitEther Coin transaction to block: Error: {:?}", e);
+			},
+			_ => {
+				warn!(target: "miner", "Added BitEther Coin transaction to block {:?}", open_block.header().number());
+			}
+		};
+
+	}
+
 	/// Check is reseal is allowed and necessary.
 	fn requires_reseal(&self, best_block: BlockNumber) -> bool {
 		let has_local_transactions = self.transaction_queue.lock().has_local_pending_transactions();